/*

Copyright (C) 2019 - 2021 Superfury

This file is part of UniPCemu.

UniPCemu is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

UniPCemu is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with UniPCemu.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "headers/types.h" //Basic types!
#include "headers/hardware/vga/vga.h" //Precalculation support for CRT timing!
#include "headers/hardware/vga/vga_cga_mda.h" //Our typedefs!
#include "headers/hardware/vga/vga_crtcontroller.h" //Our CRT timing we use!
#include "headers/hardware/vga/vga_cga_ntsc.h" //NTSC palette update support!
#include "headers/hardware/vga/vga_vram.h" //For cleaning up after byte->word mode switch!
#include "headers/support/log.h" //Logging support for dumping, if enabled!

//VGA refresh rate!
//15.75MHz originally used, but seems to be 14.31818MHz according to reenigne.org and https://pineight.com/mw/index.php?title=Dot_clock_rates
#define CGA_RATE MHZ14
//MDA refresh rate!
#ifdef IS_LONGDOUBLE
#define MDA_RATE 16257000.0L
#else
#define MDA_RATE 16257000.0
#endif

byte int10_font_08[256 * 8] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
	0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
	0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
	0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
	0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
	0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
	0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
	0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
	0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
	0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
	0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
	0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
	0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
	0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
	0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
	0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
	0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
	0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
	0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
	0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
	0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
	0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
	0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
	0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
	0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
	0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
	0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
	0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
	0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
	0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
	0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
	0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
	0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
	0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
	0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
	0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
	0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
	0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
	0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
	0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
	0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
	0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
	0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
	0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
	0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
	0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
	0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
	0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
	0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
	0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
	0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
	0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
	0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
	0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
	0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
	0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
	0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
	0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
	0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
	0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
	0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
	0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
	0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
	0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
	0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
	0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
	0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
	0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
	0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
	0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
	0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
	0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
	0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
	0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
	0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
	0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
	0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
	0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
	0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
	0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
	0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
	0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
	0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
	0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
	0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
	0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
	0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
	0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
	0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
	0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
	0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
	0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
	0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
	0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
	0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78,
	0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,
	0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
	0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00,
	0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00,
	0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00,
	0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00,
	0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38,
	0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00,
	0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
	0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
	0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00,
	0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,
	0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00,
	0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00,
	0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00,
	0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00,
	0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,
	0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,
	0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,
	0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
	0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00,
	0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
	0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18,
	0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00,
	0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30,
	0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7,
	0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70,
	0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00,
	0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00,
	0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00,
	0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00,
	0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00,
	0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00,
	0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00,
	0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f,
	0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03,
	0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,
	0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00,
	0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00,
	0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
	0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,
	0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36,
	0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36,
	0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00,
	0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36,
	0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36,
	0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36,
	0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36,
	0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
	0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00,
	0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0,
	0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00,
	0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00,
	0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00,
	0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0,
	0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00,
	0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc,
	0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00,
	0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00,
	0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00,
	0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0,
	0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00,
	0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
	0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00,
	0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00,
	0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00,
	0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00,
	0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70,
	0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00,
	0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00,
	0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c,
	0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00,
	0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

byte int10_font_14[256 * 14] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7e, 0x81, 0xa5, 0x81, 0x81, 0xbd, 0x99, 0x81,
	0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xff,
	0xdb, 0xff, 0xff, 0xc3, 0xe7, 0xff, 0x7e, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe,
	0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c,
	0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x3c, 0x3c, 0xe7, 0xe7, 0xe7, 0x18, 0x18,
	0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c,
	0x7e, 0xff, 0xff, 0x7e, 0x18, 0x18, 0x3c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
	0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xc3, 0xc3,
	0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
	0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff, 0xff,
	0xff, 0xff, 0x00, 0x00, 0x1e, 0x0e, 0x1a, 0x32,
	0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18,
	0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3f, 0x33, 0x3f, 0x30, 0x30, 0x30, 0x70, 0xf0,
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x63,
	0x7f, 0x63, 0x63, 0x63, 0x67, 0xe7, 0xe6, 0xc0,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xdb, 0x3c,
	0xe7, 0x3c, 0xdb, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf8, 0xfe, 0xf8,
	0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x06, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x06,
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c,
	0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7f, 0xdb, 0xdb, 0xdb, 0x7b, 0x1b,
	0x1b, 0x1b, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x7c,
	0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38,
	0x0c, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18,
	0x18, 0x18, 0x7e, 0x3c, 0x18, 0x7e, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60,
	0xfe, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0,
	0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x28, 0x6c, 0xfe, 0x6c, 0x28, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c,
	0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c,
	0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06,
	0x86, 0xc6, 0x7c, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x66,
	0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c,
	0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18,
	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
	0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0c, 0x18,
	0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6,
	0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6,
	0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06,
	0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe,
	0x0c, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xc6,
	0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x60,
	0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0xc6, 0x06, 0x0c,
	0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6,
	0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x0c,
	0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
	0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x30,
	0x18, 0x0c, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30,
	0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c,
	0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde,
	0xdc, 0xc0, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6,
	0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x66,
	0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0,
	0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x6c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66,
	0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x66,
	0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0,
	0xc0, 0xde, 0xc6, 0x66, 0x3a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6,
	0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x0c,
	0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xe6, 0x66, 0x6c, 0x6c,
	0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60,
	0x62, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6,
	0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xe6,
	0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6,
	0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60,
	0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c,
	0x0c, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x66,
	0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60,
	0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7e, 0x7e, 0x5a, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6,
	0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6,
	0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6,
	0xd6, 0xd6, 0xfe, 0x7c, 0x6c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x38,
	0x6c, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18,
	0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc6,
	0x8c, 0x18, 0x30, 0x60, 0xc2, 0xc6, 0xfe, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c,
	0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	0x3c, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc,
	0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x60,
	0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x7c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c,
	0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc,
	0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6,
	0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c,
	0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76,
	0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66,
	0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18,
	0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06,
	0x00, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66,
	0x3c, 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x66,
	0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6,
	0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c,
	0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66,
	0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c,
	0x0c, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c,
	0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30,
	0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6,
	0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38,
	0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e,
	0x06, 0x0c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xfe, 0xcc, 0x18, 0x30, 0x66, 0xfe, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x18, 0x18, 0x18,
	0x70, 0x18, 0x18, 0x18, 0x0e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
	0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x70, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38,
	0x6c, 0xc6, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc2,
	0x66, 0x3c, 0x0c, 0x06, 0x7c, 0x00, 0x00, 0x00,
	0xcc, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	0x76, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30,
	0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0x00, 0x78,
	0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xcc, 0xcc, 0x00, 0x78, 0x0c, 0x7c,
	0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x60,
	0x30, 0x18, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc,
	0x76, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 0x38,
	0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66,
	0x60, 0x66, 0x3c, 0x0c, 0x06, 0x3c, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xfe,
	0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xcc, 0xcc, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6,
	0x7c, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18,
	0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x00, 0x38,
	0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3c, 0x66, 0x00, 0x38, 0x18, 0x18,
	0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x60,
	0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18,
	0x3c, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0x10,
	0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,
	0x00, 0x00, 0x38, 0x6c, 0x38, 0x00, 0x38, 0x6c,
	0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x00, 0x00, 0x00,
	0x18, 0x30, 0x60, 0x00, 0xfe, 0x66, 0x60, 0x7c,
	0x60, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xcc, 0x76, 0x36, 0x7e, 0xd8, 0xd8,
	0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x6c,
	0xcc, 0xcc, 0xfe, 0xcc, 0xcc, 0xcc, 0xce, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c,
	0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0x00, 0x7c, 0xc6, 0xc6,
	0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x60,
	0x30, 0x18, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6,
	0x7c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0xcc,
	0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
	0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x00, 0xcc,
	0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0x00, 0xc6, 0xc6, 0xc6,
	0xc6, 0x7e, 0x06, 0x0c, 0x78, 0x00, 0x00, 0xc6,
	0xc6, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c,
	0x38, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0x00,
	0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x3c, 0x66, 0x60,
	0x60, 0x66, 0x3c, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60,
	0x60, 0xe6, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18, 0x7e, 0x18,
	0x18, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xcc, 0xcc,
	0xf8, 0xc4, 0xcc, 0xde, 0xcc, 0xcc, 0xc6, 0x00,
	0x00, 0x00, 0x00, 0x0e, 0x1b, 0x18, 0x18, 0x18,
	0x7e, 0x18, 0x18, 0x18, 0x18, 0xd8, 0x70, 0x00,
	0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0c, 0x7c,
	0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x0c,
	0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18,
	0x3c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x60,
	0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x30, 0x60, 0x00, 0xcc,
	0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xdc, 0x00, 0xdc, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x76, 0xdc,
	0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6,
	0xc6, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x6c, 0x6c,
	0x3e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x00,
	0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60,
	0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0x06, 0x06, 0x06, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc6, 0xcc, 0xd8,
	0x30, 0x60, 0xdc, 0x86, 0x0c, 0x18, 0x3e, 0x00,
	0x00, 0xc0, 0xc0, 0xc6, 0xcc, 0xd8, 0x30, 0x66,
	0xce, 0x9e, 0x3e, 0x06, 0x06, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x00, 0x18, 0x18, 0x3c, 0x3c, 0x3c,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x6c, 0xd8, 0x6c, 0x36, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x6c,
	0x36, 0x6c, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x55, 0xaa,
	0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,
	0x55, 0xaa, 0x55, 0xaa, 0xdd, 0x77, 0xdd, 0x77,
	0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77,
	0xdd, 0x77, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xfe, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0xf8,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x36, 0x36,
	0x36, 0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
	0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xfe,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18,
	0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3f,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36,
	0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff,
	0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0xff,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
	0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f,
	0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
	0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0xd8,
	0xd8, 0xdc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xfc, 0xc6, 0xc6, 0xfc,
	0xc0, 0xc0, 0x40, 0x00, 0x00, 0x00, 0xfe, 0xc6,
	0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x6c,
	0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0xc6, 0x60, 0x30, 0x18, 0x30,
	0x60, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0xd8,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xc0,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7e, 0x18, 0x3c, 0x66, 0x66, 0x66,
	0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x6c,
	0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c,
	0xc6, 0xc6, 0xc6, 0x6c, 0x6c, 0x6c, 0xee, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1e, 0x30, 0x18, 0x0c,
	0x3e, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xdb, 0xdb,
	0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x06, 0x7e, 0xdb, 0xdb, 0xf3, 0x7e, 0x60,
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x30,
	0x60, 0x60, 0x7c, 0x60, 0x60, 0x30, 0x1c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6,
	0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00,
	0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18,
	0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x7e, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x60,
	0x30, 0x18, 0x0c, 0x00, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
	0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc,
	0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0f, 0x0c, 0x0c, 0x0c, 0x0c,
	0x0c, 0xec, 0x6c, 0x3c, 0x1c, 0x00, 0x00, 0x00,
	0x00, 0xd8, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
	0xd8, 0x30, 0x60, 0xc8, 0xf8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

OPTINLINE byte reverse8_CGA(INLINEREGISTER byte b) { //Reverses byte value bits!
	b = ((b & 0xF0) >> 4) | ((b & 0x0F) << 4); //Swap 4 high and low bits!
	b = ((b & 0xCC) >> 2) | ((b & 0x33) << 2); //Swap 2 high and low bits of both nibbles!
	b = ((b & 0xAA) >> 1) | ((b & 0x55) << 1); //Swap odd and even bits!
	return b;
}

byte CGA_reversedinit = 1;
byte int10_font_08_reversed[256*0x20]; //Full font, reversed for optimized display!

byte getcharxy_CGA(byte character, byte x, byte y) //Retrieve a characters x,y pixel on/off from the unmodified 8x8 table!
{
	static word lastcharinfo = 0; //attribute|character, bit31=Set?
	static byte lastrow = 0; //The last loaded row!
	INLINEREGISTER word location;

	//Don't limit horizontally: this isn't needed for the CGA, but become background anyways!
	y &= 0x7; //Up to 8 rows. Rows 8+, 16+ and 24+ wrap back to row 0+(MOD 8)

	//Don't do range checks, we're always within range (because of GPU_textcalcpixel)!
	location = 0x8000 | (character << 4) | y; //The location to look up!

	if (lastcharinfo != location) //Last row not yet loaded?
	{
		lastrow = int10_font_08_reversed[(lastcharinfo = location)^0x8000]; //Read the row from the character generator to use! Also reverse the bits for faster usage, which is already done!
	}

	//Take the pixel we need!
	return ((lastrow>>x)&1); //Give result from the reversed data!
}

void fillCGAfont()
{
	if (CGA_reversedinit) //Need to initialise?
	{
		word row, character, char2;
		memset(&int10_font_08_reversed,0,sizeof(int10_font_08_reversed)); //Clear the entire font used to make sure the unused data is empty(background color)!
		for (row=0;row<sizeof(int10_font_08);row++)
		{
			character = row / 8; //Character!
			char2 = row % 8; //Line!
			int10_font_08_reversed[(character << 4) | char2] = reverse8_CGA(int10_font_08[row]);
		}
		CGA_reversedinit = 0; //Finished initialising!
	}
}

byte MDA_reversedinit = 1;
byte int10_font_14_reversed[256*0x20]; //Full font, reversed for optimized display!

byte getcharxy_MDA(byte character, byte x, byte y) //Retrieve a characters x,y pixel on/off from the unmodified 8x8 table!
{
	static word lastcharinfo = 0; //attribute|character, bit31=Set?
	static byte lastrow = 0; //The last loaded row!
	INLINEREGISTER word location;

	//Don't do range checks, we're always within range (because of GPU_textcalcpixel)!
	//Don't limit: x being 8 or up becomes a result of 0!
	y &= 0xF; //Rows 16+ wraps back to row 0(MOD 16).
	location = 0x8000 | (character << 4) | y; //The location to look up!

	if (lastcharinfo != location) //Last row not yet loaded?
	{
		lastrow = int10_font_14_reversed[(lastcharinfo = location)^0x8000]; //Read the row from the character generator to use! Also reverse the bits for faster usage, which is already done!
	}

	//Take the pixel we need!
	return ((lastrow>>x)&1); //Give result from the reversed data!
}

void fillMDAfont()
{
	if (MDA_reversedinit) //Need to initialise?
	{
		word row,character,char2;
		memset(&int10_font_14_reversed,0,sizeof(int10_font_14_reversed)); //Clear the entire font used to make sure the unused data is empty(background color)!
		for (row=0;row<sizeof(int10_font_14);row++)
		{
			character = row/14; //Character!
			char2 = row%14; //Line!
			int10_font_14_reversed[(character<<4)|char2] = reverse8_CGA(int10_font_14[row]);
		}
		MDA_reversedinit = 0; //Finished initialising!
	}
}

byte CGAMDA_is_hsync(VGA_Type *VGA, word x) //Are we vsync?
{
	if (CGAEMULATION_ENABLED_CRTC(VGA)) //CGA timings?
	{
		if ((x>=(VGA->registers->CGARegistersMasked[2]<<3)) && (x<((VGA->registers->CGARegistersMasked[2]<<3)+(VGA->registers->CGARegistersMasked[3]<<3)))) //Horizontal sync?
		{
			return 1; //Horizontal sync!
		}
	}
	else //MDA timings?
	{
		if ((x>=((VGA->registers->CGARegistersMasked[2]<<3)+VGA->registers->CGARegistersMasked[2])) && (x<(((VGA->registers->CGARegistersMasked[2]<<3)+VGA->registers->CGARegistersMasked[2])+((VGA->registers->CGARegistersMasked[3]<<3)+VGA->registers->CGARegistersMasked[3])))) //Horizontal sync?
		{
			return 1; //Horizontal sync!
		}
	}
	return 0;
}


word get_display_CGAMDA_x(VGA_Type *VGA, word x)
{
	word result=0;
	word column=x; //Unpatched x value!
	if (GETBITS(VGA->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER, 6, 1) || CGA_DOUBLEWIDTH(VGA)) //Byte mode and double width seems to affect timings?
	{
		column >>= 1; //Half the horizontal timing!
		x >>= 1; //Half the horizontal timing!
	}
	if (CGAEMULATION_ENABLED_CRTC(VGA)) //CGA timings?
		column >>= 3; //Divide by 8 to get the character clock!
	else //MDA timings?
		column = VGA->precalcs.divideby9[column]; //Divide by 9 to get the character clock!

	if (column>(VGA->registers->CGARegistersMasked[0])) //Past total specified?
	{
		result |= VGA_SIGNAL_HTOTAL; //End of display: start the next frame!
		result |= VGA_SIGNAL_HSYNCRESET; //Reset HSync!
	}
	if (CGAMDA_is_hsync(VGA,x)) //Horizontal sync?
	{
		result |= VGA_SIGNAL_HRETRACESTART; //Start horizontal sync!
	}
	else if (x && CGAMDA_is_hsync(VGA,x-1)) //Previous was hsync?
	{
		result |= VGA_SIGNAL_HRETRACEEND; //End horizontal sync!
	}
	if (column<VGA->registers->CGARegistersMasked[1]) //Are we displayed?
	{
		result |= VGA_HACTIVEDISPLAY; //Horizontal displayed!
	}
	else
	{
		result |= VGA_OVERSCAN; //We're overscan by default!
	}
	return result; //Give the signal!
}

DOUBLE getCGAMDAClock(VGA_Type *VGA)
{
	DOUBLE result=0.0f; //The calculated clock speed! Default: not used!
	VGA->precalcs.use14MHzclock = 0; //Default to normal clocking!
	if (CGAMDAEMULATION_ENABLED_CRTC(VGA)) //Are we enabled?
	{
		if (CGAEMULATION_ENABLED_CRTC(VGA)) //CGA emulation enabled?
		{
			result = CGA_RATE; //Special CGA compatibility mode: change our refresh speed to match it according to CGA specifications! Pixel speed is always 14MHz!
			VGA->precalcs.use14MHzclock = 1; //Use the motherboard CGA 14MHz clocking!
		}
		else if (MDAEMULATION_ENABLED_CRTC(VGA)) //MDA emulation enabled?
		{
			result = MDA_RATE; //16.257MHz pixel clock!
		}
	}
	return result; //Default: No CGA/MDA clock used!
}

byte CGA_is_vsync(VGA_Type *VGA, word y, byte charheight) //Are we vsync?
{
	if ((y>=(VGA->registers->CGARegistersMasked[7]*charheight)) && (y<((VGA->registers->CGARegistersMasked[7]*charheight)+0x10))) //Vertical sync? It's always 16 lines!
	{
		return 1; //Vertical sync!
	}
	return 0;
}

word get_display_CGAMDA_y(VGA_Type *VGA, word y)
{
	word result=0;
	if (!y) result |= VGA_SIGNAL_VRETRACEEND|VGA_SIGNAL_VBLANKEND; //End vertical retrace&blank if still there!
	word row;
	byte charheight;
	charheight = VGA->registers->CGARegistersMasked[9]+1; //Character height!
	row = y;
	row /= charheight; //The row we're at!
	if (row>=VGA->registers->CGARegistersMasked[4]) //Past total specified?
	{
		if ((((VGA->registers->CGARegistersMasked[4]+1)*charheight)+VGA->registers->CGARegistersMasked[5])<=y) //Vertical total adjustment reaced?
		{
			result |= VGA_SIGNAL_VTOTAL; //End of display: start the next frame!
			result |= VGA_SIGNAL_VSYNCRESET; //Reset VSync!
		}
	}

	if (row<VGA->registers->CGARegistersMasked[6]) //Active display?
	{
		result |= VGA_VACTIVEDISPLAY; //We're active display!
	}
	else
	{
		result |= VGA_OVERSCAN; //We're overscan by default!
	}

	if (CGA_is_vsync(VGA,y,charheight)) //Vertical sync?
	{
		result |= VGA_SIGNAL_VRETRACESTART; //Vertical sync is simply blanking space!
	}
	else if (y && CGA_is_vsync(VGA,y-1,charheight)) //Previous was vsync?
	{
		result |= VGA_SIGNAL_VRETRACEEND; //End of retrace period, if any!
	}
	return result; //Give the signal!
}

//Support for the I/O updating!
OPTINLINE void updateCGAMDAflags()
{
	if (!getActiveVGA()) return;
	if (!getActiveVGA()->registers) return;
	if ((getActiveVGA()->registers->specialCGAflags != getActiveVGA()->precalcs.LastCGAFlags) || (getActiveVGA()->registers->specialMDAflags != getActiveVGA()->precalcs.LastMDAFlags)) //CGA/MDA flags updated?
	{
		getActiveVGA()->precalcs.LastCGAFlags = getActiveVGA()->registers->specialCGAflags; //Update the last value used!
		getActiveVGA()->precalcs.LastMDAFlags = getActiveVGA()->registers->specialMDAflags; //Update the last value used!
		VGA_calcprecalcs(getActiveVGA(), WHEREUPDATED_ALL_SECTION | WHEREUPDATED_CRTCONTROLLER); //We have been updated! Update the whole section, as we don't know anything about the exact registers affected by the special action!
	}
	getActiveVGA()->registers->specialCGAMDAflags = getActiveVGA()->registers->specialCGAflags | getActiveVGA()->registers->specialMDAflags; //Combined flags for fast detection!
}

//Finally, main support layer!
void setVGA_CGA(byte enabled)
{
	if (enabled)
	{
		if (enabled==1) //Pure CGA Mode?
		{
			getActiveVGA()->registers->specialCGAflags |= 1; //Enable CGA!
			getActiveVGA()->registers->specialCGAflags &= ~0x80; //Disable VGA!
		}
		else
		{
			getActiveVGA()->registers->specialCGAflags |= 0x81; //Enable VGA and CGA!
		}
	}
	else
	{
		getActiveVGA()->registers->specialCGAflags = 0; //Disable CGA!
	}
	updateCGAMDAflags(); //Update our mapped flags!
}

void setVGA_MDA(byte enabled)
{
	if (enabled)
	{
		if (enabled==1) //Pure MDA Mode?
		{
			getActiveVGA()->registers->specialMDAflags |= 1; //Enable MDA!
			getActiveVGA()->registers->specialMDAflags &= ~0x80; //Disable VGA!
		}
		else
		{
			getActiveVGA()->registers->specialMDAflags |= 0x81; //Enable VGA and MDA!
		}
	}
	else
	{
		getActiveVGA()->registers->specialMDAflags = 0; //Disable MDA!
	}
	updateCGAMDAflags(); //Update our mapped flags!
}

//Data conversion from CGA to VGA compatibility layer.

//Foreground colors: Red green yellow(not set), Magenta cyan white(set), Black red cyan white on a color monitor(RGB)!
byte CGA_lowcolors[3][4] = {{0,0x2,0x4,0x6},{0,0x3,0x5,0x7},{0,0x3,0x4,0x7}};
extern byte CGA_RGB; //Are we a RGB monitor(1) or Composite monitor(0)?

OPTINLINE void setCGAMDAColors(byte isGraphics, byte GraphicsMode)
{
	byte i,color;
	if ((!isGraphics) && GraphicsMode) //MDA enabled?
	{
		//Apply the MDA palette registers!
		for (i=0;i<0x10;i++) //Process all colours!
		{
			color = 0; //Default to black!
			if (i&0x8) //Bright(8-F)?
			{
				color |= 2; //Set bright attribute!
			}
			if (i&0x7) //On (1-7 and 9-15)?
			{
				color |= 1; //Set on attribute!
			}
			switch (color) //What color to map?
			{
				default:
				case 0: //Black=Black!
				case 3: //Bright foreground=Bright foreground!
					break;
				case 1: //Normal on?
					color = 2; //Bright!
					break;
				case 2: //Bright background!
					color = 1; //Lighter!
					break;
			}
			getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.PALETTEREGISTERS[i] = color; //Make us equal!
		}
		getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.OVERSCANCOLORREGISTER = 0; //This forces black overscan! We don't have overscan!		
	}
	//Apply the new CGA palette register?
	else if (isGraphics) //Graphics mode?
	{
		if (!GraphicsMode) //High resolution graphics mode(640 pixels)?
		{
			getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.OVERSCANCOLORREGISTER = 0; //Black overscan!
		}

		for (i=0;i<0x10;i++) //Process all colours!
		{
			color = i; //Default to the normal color!
			if (GraphicsMode) //Color mode? 320x200!
			{
				if (!i) //Background color?
				{
					color = (getActiveVGA()->registers->Compatibility_CGAPaletteRegister&0xF); //Use the specified background color!
					getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.OVERSCANCOLORREGISTER = color; //It also applies to the overscan!
				}
				else //Three foreground colors?
				{
					if (getActiveVGA()->registers->Compatibility_CGAModeControl&0x4) //Disabling the color burst bit applies 3rd palette on RGB monitor?
					{
						color = CGA_lowcolors[2][i&3]; //Use the RGB-specific 3rd palette!
					}
					else //Normal palettes?
					{
						color = CGA_lowcolors[(getActiveVGA()->registers->Compatibility_CGAPaletteRegister&0x20)?1:0][i&3]; //Don't use the RGB palette, use the normal palettes!
					}
					if (getActiveVGA()->registers->Compatibility_CGAPaletteRegister&0x10) //Display in high intensity?
					{
						color |= 0x8; //Display in high intensity!
					}
				}
			}
			else //B/W mode?
			{
				if (i) //We're on?
				{
					color = (getActiveVGA()->registers->Compatibility_CGAPaletteRegister&0xF); //Use the specified ON color!
				}
			}
			getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.PALETTEREGISTERS[i] = color; //Make us the specified value!
		}
	}
	else //Text mode?
	{
		for (i=0;i<0x10;i++) //Process all colours!
		{
			getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.PALETTEREGISTERS[i] = i; //Make us equal!
		}
		getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.OVERSCANCOLORREGISTER = (getActiveVGA()->registers->Compatibility_CGAPaletteRegister&0xF);
	}

	VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL_SECTION|WHEREUPDATED_ATTRIBUTECONTROLLER); //We have been updated(whole attribute controller mode)!
	RENDER_updateCGAColors(); //Update the NTSC color translation if required!
}

//Compatibility handling on both writes and reads to compatibility registers!
OPTINLINE void applyCGAMDAPaletteRegisters()
{
	if (getActiveVGA()->registers->specialMDAflags&1) //MDA mode?
	{
		setCGAMDAColors(0,1); //MDA text mode!
	}
	else if (getActiveVGA()->registers->Compatibility_CGAModeControl&0x2) //Graphics mode?
	{
		if (getActiveVGA()->registers->Compatibility_CGAModeControl&0x10) //2 colour graphics?
		{
			setCGAMDAColors(1,0); //Set up basic 2-color graphics!
		}
		else //4 colour?
		{
			setCGAMDAColors(1,1); //Set up basic 4-color graphics!
		}
	}
	else //Text mode?
	{
		setCGAMDAColors(0,0); //CGA Text mode!
	}
}

OPTINLINE void applyCGAPaletteRegister() //Update the CGA colors!
{
	applyCGAMDAPaletteRegisters(); //Apply the palette registers!
}

OPTINLINE void updateCGAmapping()
{
	switch (getActiveVGA()->registers->CGARegisters[8]&3) //What mode?
	{
		case 0:
		case 2: //Straight?
			if (getActiveVGA()->registers->Compatibility_CGAModeControl&2) //Graphics mode?
			{
				SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,0,1,0); //Graphics enables CGA graphics MAP13, else text!
			}
			else //Text mode?
			{
				SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,0,1,1); //Graphics enables CGA graphics MAP13, else text!
			}
			SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,5,1,1); //CGA mapping is done by the renderer mapping CGA!
			break;
		case 1: //Interleaved?
			SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,0,1,0); //Graphics enables CGA graphics MAP13, else text!
			SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,5,1,0); //CGA mapping is done by the renderer mapping CGA!
			break;
		case 3: //Interleaved video?
			SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,0,1,0); //Graphics enables CGA graphics MAP13, else text!
			SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,5,1,1); //CGA mapping is done by the renderer mapping CGA!
			break;
		default:
			break;
	}
}

//useGraphics: 0 for text mode, 1 for graphics mode! GraphicsMode: 0=B/W graphics or CGA text mode, 1=4 color graphics or MDA text mode
OPTINLINE void setCGAMDAMode(byte useGraphics, byte GraphicsMode, byte blink) //Rendering mode set!
{ 
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,5,1,((useGraphics && GraphicsMode)?1:0));
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.MISCGRAPHICSREGISTER,0,1,useGraphics);
	getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.COLORPLANEENABLEREGISTER = (useGraphics&&!GraphicsMode)?0x1:0xF; //CGA: enable all color planes!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,0,1,useGraphics); //Text mode!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,1,1,((!useGraphics) && GraphicsMode)); //MDA attributes!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,3,1,((!useGraphics) && blink)?1:0); //Use blink when not using graphics and blink is enabled!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.UNDERLINELOCATIONREGISTER,0,0x1F,((!useGraphics) && GraphicsMode)?0xC:0x1F); //Monochrome emulation applies MDA-compatible underline, simple detection by character height!
	updateCGAmapping(); //Update the rendering mapping by the CGA!
}

extern uint_32 VGA_VRAM_START; //To copy memory between VRAM modes!

OPTINLINE void applyCGAMemoryMap(byte useGraphics, byte GraphicsMode) //Apply the current CGA memory map!
{
	uint_32 memaddr;
	word bytesleft;
	byte memorymode;
	
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.MISCGRAPHICSREGISTER,2,3,((!useGraphics) && GraphicsMode)?2:3); //Use map B000(MDA) or B800(CGA), depending on the adapter used!
	memorymode = (GETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,6,1))|((useGraphics && (!GraphicsMode))?2:0); //New memory mode!
	if (useGraphics && (!GraphicsMode)) //Special case? CGA monochrome mode?
	{
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,4,1,0); //Don't force odd/even mode!
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.READMAPSELECTREGISTER,0,3,0); //Only read map #0!
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.COLORDONTCAREREGISTER,0,0xF,0); //Care about this only!
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.MISCGRAPHICSREGISTER,1,1,0); //Disable chaining!
		SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.SEQUENCERMEMORYMODEREGISTER,2,1,1); //Disable odd/even mode!
		getActiveVGA()->registers->SequencerRegisters.REGISTERS.MAPMASKREGISTER = 1; //Write to plane 0 only, since we're emulating CGA!
		SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,6,1,1); //CGA byte mode!
	}
	else //Revert to normal memory mode!
	{
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,4,1,1); //Force odd/even mode!
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.READMAPSELECTREGISTER,0,3,0); //Only read map #0!
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.COLORDONTCAREREGISTER,0,0xF,0xF); //Care about this only!
		SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.MISCGRAPHICSREGISTER,1,1,1); //Enable chaining!
		SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.SEQUENCERMEMORYMODEREGISTER,2,1,0); //Disable odd/even mode!
		getActiveVGA()->registers->SequencerRegisters.REGISTERS.MAPMASKREGISTER = 3; //Write to planes 0/1 only, since we're emulating CGA!
		SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,6,1,0); //CGA word mode!
	}
	VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_HORIZONTAL|0x1); //The horizontal size might have been updated!
	if (getActiveVGA()->CGAMDAMemoryMode!=memorymode) //Memory mode updated?
	{
		getActiveVGA()->CGAMDAMemoryMode = memorymode; //Updating memory!
		bytesleft = CGAEMULATION_ENABLED(getActiveVGA())?0x4000:0x1000; //How much to copy(CGA vs MDA)!
		memset(getActiveVGA()->VRAM, 0, getActiveVGA()->VRAM_size); //Clear all VRAM addresses for the new mode to fill!
		memaddr = 0; //Start of address to write!
		for (;bytesleft--;) //Process all RAM!
		{
			CGAMDA_doWriteRAMrefresh(memaddr++); //Copy shadow RAM to VRAM, keeping the layout identical(like we're using normal CGA VRAM)!
		}
	}
}

OPTINLINE void applyCGAModeControl()
{
	//Apply the new CGA mode control register?
	if (getActiveVGA()->registers->Compatibility_CGAModeControl&8) //Video enabled on the CGA?
	{
		if (getActiveVGA()->registers->Compatibility_MDAModeControl&8) //MDA also enabled?
		{
			getActiveVGA()->registers->Compatibility_MDAModeControl &= ~8; //Disable the MDA!
		}
	}
	if (getActiveVGA()->registers->Compatibility_CGAModeControl&0x2) //Graphics mode?
	{
		if (getActiveVGA()->registers->Compatibility_CGAModeControl&0x10) //2 colour?
		{
			setCGAMDAMode(1,0,(getActiveVGA()->registers->Compatibility_CGAModeControl&0x20)); //Set up basic 2-color graphics!
			applyCGAMemoryMap(1,0);
		}
		else //4 colour?
		{
			setCGAMDAMode(1,1,(getActiveVGA()->registers->Compatibility_CGAModeControl&0x20)); //Set up basic 4-color graphics!
			applyCGAMemoryMap(1,1);
		}
	}
	else //Text mode?
	{
		setCGAMDAMode(0,0,(getActiveVGA()->registers->Compatibility_CGAModeControl&0x20)); //Text mode!
		applyCGAMemoryMap(0,0);
	}
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.CLOCKINGMODEREGISTER,5,1,(getActiveVGA()->registers->Compatibility_CGAModeControl&8)?0:1); //Disable the screen when requested! Interpret the RAM as zeroes(black) when disabled!
	applyCGAMDAPaletteRegisters(); //Apply the palette registers according to our settings!
	VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL); //We have been updated!	
}

OPTINLINE void applyMDAModeControl()
{
	//Apply the new MDA mode control register?
	if (getActiveVGA()->registers->Compatibility_MDAModeControl&8) //Video enabled on the MDA?
	{
		if (getActiveVGA()->registers->Compatibility_CGAModeControl&8) //CGA also enabled?
		{
			getActiveVGA()->registers->Compatibility_CGAModeControl &= ~8; //Disable the CGA!
		}
		setCGAMDAMode(0,1,(getActiveVGA()->registers->Compatibility_MDAModeControl&0x20)); //Text mode!
		applyCGAMemoryMap(0,1);
	}
	applyCGAMDAPaletteRegisters(); //Apply the palette registers according to our settings!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.CLOCKINGMODEREGISTER,5,1,(getActiveVGA()->registers->Compatibility_MDAModeControl&8)?0:1); //Disable the screen when requested! Interpret the RAM as zeroes(black) when disabled!
	VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL); //We have been updated!
}

OPTINLINE void applyCGAMDAMode() //Apply VGA to CGA/MDA Mode conversion(setup defaults for all registers not used by the CGA/MDA emulation)!
{
	//Now, setup defaults for the CGA/MDA to be used(normal data)! Clear any unused registers!
	//Graphics Controller: Fully set!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.SETRESETREGISTER,0,0xF,0); //Disable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.ENABLESETRESETREGISTER,0,0xF,0); //No set/reset used!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.DATAROTATEREGISTER,0,7,0); //No special operation!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.DATAROTATEREGISTER,3,3,0); //No special operation!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.COLORCOMPAREREGISTER,0,0xF,0); //Disable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.READMAPSELECTREGISTER,0,3,0); //Disable/Plane 0!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,0,3,0); //Disable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,3,1,0); //Disable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,4,1,1); //Enable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.GRAPHICSMODEREGISTER,6,1,0); //Disable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.MISCGRAPHICSREGISTER,1,1,1); //Enable!
	SETBITS(getActiveVGA()->registers->GraphicsRegisters.REGISTERS.COLORDONTCAREREGISTER,0,0xF,0xF); //Care about this only!
	getActiveVGA()->registers->GraphicsRegisters.REGISTERS.BITMASKREGISTER = 0xFF; //Use all bits supplied by the CPU!
	//Sequencer: Fully set!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.RESETREGISTER,0,1,1); //Start the sequencer!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.RESETREGISTER,1,1,1); //Start the sequencer!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.CLOCKINGMODEREGISTER,4,1,0); //CGA display!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.CLOCKINGMODEREGISTER,3,1,0); //CGA display! Single pixels only!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.CLOCKINGMODEREGISTER,2,1,0); //CGA display! Single load rate!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.CLOCKINGMODEREGISTER,0,1,(MDAEMULATION_ENABLED_CRTC(getActiveVGA()))?0:1); //CGA display: 8 dots/character. MDA display: 9 dots/character!
	getActiveVGA()->registers->SequencerRegisters.REGISTERS.MAPMASKREGISTER = 3; //Write to planes 0/1 only, since we're emulating CGA!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.SEQUENCERMEMORYMODEREGISTER,1,1,0); //Write to planes 0/1 only, since we're emulating CGA! We're wrapping around 16KB, so only 64K applied(16K with double 4 bytes per index=64K memory).
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.SEQUENCERMEMORYMODEREGISTER,2,1,0); //Write to planes 0/1 only, since we're emulating CGA!
	SETBITS(getActiveVGA()->registers->SequencerRegisters.REGISTERS.SEQUENCERMEMORYMODEREGISTER,3,1,0); //Write to planes 0/1 only, since we're emulating CGA!
	//CRT Controller: Fully set!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.UNDERLINELOCATIONREGISTER,6,1,0); //CGA normal mode!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.UNDERLINELOCATIONREGISTER,5,1,0); //CGA normal mode!
	getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.LINECOMPAREREGISTER = 0xFF; //Maximum line compare: no split screen!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.OVERFLOWREGISTER,4,1,1); //Maximum line compare: no split screen!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.MAXIMUMSCANLINEREGISTER,6,1,1); //Maximum line compare: no split screen!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CURSORENDREGISTER,5,3,0); //Don't use any cursor skewing: we're direct line numbers for the scanline within the character!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.VERTICALRETRACEENDREGISTER,5,1,1); //Disable the VRetrace interrupts!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,2,1,0); //CGA no scanline division!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,3,1,0); //CGA normal mode?
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,7,1,1); //CGA enable CRT rendering HSYNC/VSYNC!
	//Memory mapping special: always map like a CGA!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,6,1,0); //CGA word mode!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,5,1,0); //CGA mapping is done by the renderer mapping CGA!
	SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.CRTCMODECONTROLREGISTER,1,1,1); //CGA mapping!
	//Attribute Controller: Fully set!
	VGA_3C0_PALW(1); //Enable the palette!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,2,1,1); //CGA line graphics!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,5,1,0); //CGA pixel panning mode!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,6,1,0); //Not using 8-bit colors!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.ATTRIBUTEMODECONTROLREGISTER,7,1,0); //Not using the high Palette bits!
	getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.COLORPLANEENABLEREGISTER |= 0xF; //CGA: enable all color planes!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.HORIZONTALPIXELPANNINGREGISTER,0,0xF, (CGAEMULATION_ENABLED_CRTC(getActiveVGA()))?0:8); //Don't shift!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.COLORSELECTREGISTER,0,3,0); //Don't use!
	SETBITS(getActiveVGA()->registers->AttributeControllerRegisters.REGISTERS.COLORSELECTREGISTER,2,3,0); //Don't use!
	//External registers: Fully set!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1,(CGAEMULATION_ENABLED_CRTC(getActiveVGA()))?1:0); //CGA/MDA address!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,1,1,1); //CGA!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,5,1,1); //CGA!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,6,1,0); //CGA has positive polarity!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,7,1,0); //CGA has positive polarity!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.FEATURECONTROLREGISTER,0,1,0); //CGA!
	SETBITS(getActiveVGA()->registers->ExternalRegisters.FEATURECONTROLREGISTER,1,1,1); //CGA!
	VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL); //We have been updated(full VGA)!
}

OPTINLINE void CGA_clearlightpenlatch()
{
	if (CGAEMULATION_ENABLED(getActiveVGA())) //CGA is emulated?
	{
		getActiveVGA()->registers->specialCGAflags &= ~0x6; //Clear the lightpen latch and untrigger it!
	}
}

extern word Sequencer_location; //Current location we're processing!

OPTINLINE void CGA_presetlightpenlatch()
{
	if (CGAEMULATION_ENABLED(getActiveVGA())) //CGA is emulated?
	{
		getActiveVGA()->registers->specialCGAflags |= 0x2; //Triggered the lightpen latch! Now wait for it to set by the first hardware input without the light pen pulse!
	}
}

void CGA_checklightpen(word currentlocation, byte is_lightpenlocation, byte is_lightpenpressed) //Check the lightpen on the current location!
{
	word lightpenlocation;
	if (likely(CGAEMULATION_ENABLED(getActiveVGA())==0)) return; //CGA is emulated? Not used for most of the hardware! VGA and all SVGA cards don't use this!
	{
		if (((getActiveVGA()->registers->specialCGAflags&6)==2) || (is_lightpenlocation && ((getActiveVGA()->registers->specialCGAflags&4)==0))) //Light pen preset or light pen pulse at our location?
		{
			getActiveVGA()->registers->specialCGAflags &= ~2; //Clear the preset: we're not set anymore!
			getActiveVGA()->registers->specialCGAflags |= 4; //The light pen register is now set!
			lightpenlocation = currentlocation; //Load the current location for converting to CGA location!
			//Translate VGA location to CGA location!
			//Now set our lightpen location!
			getActiveVGA()->registers->CGARegisters[0x10] &= ~0x3F; //Clear our light pen location bits that need to be set!
			getActiveVGA()->registers->CGARegisters[0x10] = ((lightpenlocation>>8)&0x3F); //Our high bits!
			getActiveVGA()->registers->CGARegisters[0x11] = (lightpenlocation&0xFF); //Our low bits!
		}
		//Always update the CGA lightpen button(live state)!
		getActiveVGA()->registers->specialCGAflags &= ~8; //Clear the switch output: we're off by default!
		getActiveVGA()->registers->specialCGAflags |= ((is_lightpenpressed&1)<<3); //Set the switch status to be read by the CPU!
	}
}

//I/O compatibility layer!

#ifdef VGAIODUMP
extern DOUBLE VGA_debugtiming; //Debug countdown if applyable!
extern byte VGA_debugtiming_enabled; //Are we applying right now?
//CGA dumping support!
OPTINLINE byte dumpCGAIO()
{
	if (VGA_debugtiming_enabled) //Are we enabled?
	{
		if (VGA_debugtiming>VGAIODUMP) //Expired?
		{
			VGA_debugtiming_enabled = 0; //Finished dumping!
			VGA_debugtiming = 0.0f; //Reset the counter as well!
			return 0; //Disabled!
		}
		return 1; //Enabled dumping for now until we expire!
	}
	return 0; //Disabled!
}
#endif


byte CGAMDA_readIO(word port, byte *result)
{
	INLINEREGISTER byte temp; //Temporary result!
	byte ok = 0;
	if ((getActiveVGA()->registers->specialCGAMDAflags)&1) //Extension enabled?
	{
		switch (port) //What port?
		{
		//EGA/VGA registers are unsupported?
		case 0x3C0: //Attribute Address/Data register		ADDRESS/DATA
		case 0x3C1: //Attribute Data Read Register		DATA
		case 0x3C2: //Read: Input Status #0 Register		DATA
		case 0x3C3: //Video subsystem enable?
		case 0x3C4: //Sequencer Address Register		ADDRESS
		case 0x3C5: //Sequencer Data Register			DATA
		case 0x3C6: //DAC Mask Register?
		case 0x3C7: //Read: DAC State Register			DATA
		case 0x3C8: //DAC Address Write Mode Register		ADDRESS
		case 0x3C9: //DAC Data Register				DATA
		case 0x3CA: //Read: Feature Control Register		DATA
		case 0x3CC: //Read: Miscellaneous Output Register	DATA
		case 0x3CE: //Graphics Controller Address Register	ADDRESS
		case 0x3CF: //Graphics Controller Data Register		DATA
			if (((getActiveVGA()->registers->specialCGAflags&0x81)==1) || ((getActiveVGA()->registers->specialMDAflags&0x81)==1)) //CGA doesn't have VGA registers!
			{
				ok = 2; //Ignore us! We become undefined!
			}
			else if ((getActiveVGA()->registers->specialCGAflags&0x41)==0x41) //CGA on VGA, which is enabled?
			{
				ok = 2; //Ignore us! We become undefined!
			}
			else if ((getActiveVGA()->registers->specialMDAflags&0x41)==0x41) //MDA on VGA, which is enabled?
			{
				ok = 2; //Ignore us! We become undefined!
			}
			break;

		//CGA/MDA CRTC registers!
		case 0x3B1:
		case 0x3B3:
		case 0x3B7: //Decodes to 3B5!
		case 0x3B5: //CRTC Controller Data Register		5DATA
			if (GETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1)) goto finishinput; //Block: we're a color mode addressing as mono!
			goto readcrtvalue;
		case 0x3D5: //CRTC Controller Data Register		DATA
			if (GETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1)==0) goto finishinput; //Block: we're a mono mode addressing as color!
			readcrtvalue:
			if (CGAMDAEMULATION_ENABLED_CRTC(getActiveVGA())) //Special CGA flag set for CRTC?
			{
				if ((getActiveVGA()->registers->CRTControllerRegisters_Index<0xE) || (getActiveVGA()->registers->CRTControllerRegisters_Index>0x11)) //Only the Cursor and light pen registers are readable!
				{
					goto finishinput;
				}
				*result = getActiveVGA()->registers->CGARegisters[getActiveVGA()->registers->CRTControllerRegisters_Index]; //Give the CGA register!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(R)CRTC[%02X]=%02X",getActiveVGA()->registers->CRTControllerRegisters_Index,*result); //Log the read!
					}
				#endif
				ok = 1;
				goto finishinput; //Finish us! Don't use the VGA registers!
			}
			ok = 0; //We're not enabled for this port!
			break;
	
		//Status registers!
		case 0x3BA:	//Read: Input Status #1 Register (mono)	DATA
			if (GETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1)) goto finishinput; //Block: we're a color mode addressing as mono!
			goto readInputStatus1;
		case 0x3DA: //Input Status #1 Register (color)	DATA
			if (GETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1)==0) goto finishinput; //Block: we're a mono mode addressing as color!
			readInputStatus1:
			SETBITS(getActiveVGA()->registers->CRTControllerRegisters.REGISTERS.ATTRIBUTECONTROLLERTOGGLEREGISTER,7,1,0); //Reset flipflop for 3C0!
			temp = getActiveVGA()->registers->ExternalRegisters.INPUTSTATUS1REGISTER; //Give!
			if (CGAMDAEMULATION_ENABLED(getActiveVGA())) //CGA/MDA emulation enabled normally?
			{
				if (MDAEMULATION_ENABLED(getActiveVGA())) //3BA doesn't have bit 4? Bit4=Mono operation!
				{
					temp &= ~8; //Clear the VRetrace bit: we're mono operation, as we're the monochrome port used!
					if ((getActiveVGA()->registers->specialMDAflags&0x81)==1) //Pure MDA mode?
					{
						temp &= ~0x06; //Clear bits 2-1 on real IBM MDA!
						temp |= 0xF0; //Set bit 7-4 on real IBM MDA!
					}
				}
				else if (CGAEMULATION_ENABLED(getActiveVGA())) //CGA status port?
				{
					temp &= ~7; //Clear the light pen data and display disabled by default!
					//Bit 1=1: Light pen triggered, Bit 2=1: Light Pen switch is open
					temp |= ((getActiveVGA()->registers->specialCGAflags&0x4)>>1); //Bit 1 used normally!
					temp |= (((~getActiveVGA()->registers->specialCGAflags&0x8))>>1); //Bit 2 used to give the status (0=on/pressed according to documentation)!				
					temp |= ((~getActiveVGA()->CRTC.DisplayEnabled)&1); //Bit0=0 when active display area. Else 1.
					#ifdef VGAIODUMP
						if (dumpCGAIO()) //To dump?
						{
							dolog("CGA_IO","(R)Status=%02X",temp); //Log the read!
						}
					#endif
				} //Else: normal VGA documented result!
			}
			*result = temp; //Store the result!
			ok = 1;
			break;
		case 0x3DB: //Clear lightpen latch?
			if (CGAMDAEMULATION_ENABLED(getActiveVGA()))  //Special CGA flag set for CRTC?
			{
				CGA_clearlightpenlatch(); //Clear lightpen latch!
				ok = 2; //Accept, but ignore!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(R)Clear lightpen latch"); //Log the read!
					}
				#endif
			}
			break;
		case 0x3DC: //Preset lightpen latch?
			if (CGAMDAEMULATION_ENABLED(getActiveVGA()))  //Special CGA flag set for CRTC?
			{
				CGA_presetlightpenlatch(); //Preset lightpen latch!
				ok = 2; //Accept, but ignore!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(R)Preset lightpen latch"); //Log the read!
					}
				#endif
			}
			break;
		//CGA/MDA compatibility registers!
		case 0x3D8: //CGA mode control register
			if (getActiveVGA()->registers->specialCGAflags&0x1) //Not NMI used on CGA-specific registers being called?
			{
				*result = getActiveVGA()->registers->Compatibility_CGAModeControl; //Set the MDA Mode Control Register!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(R)Mode Control=%02X",*result); //Log the read!
					}
				#endif
				ok = 1; //OK!
			}
			break;
		case 0x3D9: //CGA palette register
			if (getActiveVGA()->registers->specialCGAflags&0x1) //Not NMI used on CGA-specific registers being called?
			{
				*result = getActiveVGA()->registers->Compatibility_CGAPaletteRegister; //Set the MDA Mode Control Register!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(R)Palette=%02X",*result); //Log the read!
					}
				#endif
				ok = 1; //OK!
			}
			break;
		case 0x3B8: //MDA Mode Control Register
			if (getActiveVGA()->registers->specialMDAflags&0x1) //Not NMI used on MDA-specific registers being called?
			{
				*result = getActiveVGA()->registers->Compatibility_MDAModeControl; //Set the MDA Mode Control Register!
				ok = 1; //OK!
			}
			break;
		default: //Unknown?
			return 0; //Not our port!
		}
	}
	finishinput:
	return ok; //We're used!
}

byte CGAMDA_writeIO(word port, byte value)
{
	byte ok = 0;
	if (!getActiveVGA()) return 2; //Invalid VGA!
	if (!getActiveVGA()->registers) return 2; //Invalid registers!
	if ((getActiveVGA()->registers->specialCGAMDAflags)&1) //Extension enabled!
	{
		switch (port)
		{
		//EGA/VGA registers are unsupported?
		case 0x3BA: //Write: Feature Control Register (mono)		DATA
		case 0x3CA: //Same as above!
		case 0x3C0: //Attribute Address/Data register		ADDRESS/DATA
		case 0x3C1: //Attribute Data Read Register		DATA
		case 0x3C2: //Write: Miscellaneous Output Register	DATA
		case 0x3CC: //Same as above!
		case 0x3C3: //Video subsystem enable
		case 0x3C4: //Sequencer Address Register		ADDRESS
		case 0x3C5: //Sequencer Data Register			DATA
		case 0x3C6: //DAC Mask Register?
		case 0x3C7: //Write: DAC Address Read Mode Register	ADDRESS
		case 0x3C8: //DAC Address Write Mode Register		ADDRESS
		case 0x3C9: //DAC Data Register				DATA
		case 0x3CE: //Graphics Controller Address Register	ADDRESS
		case 0x3CF: //Graphics Controller Data Register		DATA
			if (CGAMDAEMULATION_ENABLED(getActiveVGA())) //CGA doesn't have VGA registers!
			{
				ok = 2; //Ignore us! We become undefined!
			}
			break;

		//CGA/MDA CRTC registers!
		case 0x3B1:
		case 0x3B3:
		case 0x3B7: //Decodes to 3B5!
		case 0x3B5: //CRTC Controller Data Register		DATA
			if (GETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1)) goto finishoutput; //Block: we're a color mode addressing as mono!
			goto accesscrtvalue;
		case 0x3D5: //CRTC Controller Data Register		DATA
			if (!GETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1)) goto finishoutput; //Block: we're a mono mode addressing as color!
			accesscrtvalue:
			if (CGAMDAEMULATION_ENABLED_CRTC(getActiveVGA()))  //Special CGA flag set for CRTC?
			{
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(W)CRTC[%02X]=%02X",getActiveVGA()->registers->CRTControllerRegisters_Index,value); //Log the write!
					}
				#endif
				if (getActiveVGA()->registers->CRTControllerRegisters_Index>=0x12) goto skipCRTwrite; //Invalid register, just handle normally(skip it)!
				if (getActiveVGA()->registers->CRTControllerRegisters_Index&0x10) goto skipCRTwrite; //Light pen is read-only on the CGA!
				getActiveVGA()->registers->CGARegisters[getActiveVGA()->registers->CRTControllerRegisters_Index] = value; //Set the CGA register!
				getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value; //Set the CGA register(unmasked)!
				switch (getActiveVGA()->registers->CRTControllerRegisters_Index) //Check address registers to translate from the CGA!
				{
				case 0x0: //HTotal?
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_HORIZONTAL|0x00); //This CRT Register has been updated!
					break;
				case 0x1: //H Displayed?
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_HORIZONTAL|0x01); //This CRT Register has been updated!
					break;
				case 0x2: //H Sync Position?
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_HORIZONTAL|0x02); //This CRT Register has been updated!
					break;
				case 0x3: //H Sync Width?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0xF; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_HORIZONTAL|0x03); //This CRT Register has been updated!
					break;
				case 0x4:  //Special CGA compatibilty action? Vertical total register?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x7F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_VERTICAL|0x04); //This CRT Register has been updated!
					break;
				case 0x5: //V Total Adjust?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x1F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_VERTICAL|0x05); //This CRT Register has been updated!
					break;
				case 0x6: //V Displayed?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x7F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_VERTICAL|0x06); //This CRT Register has been updated!
					break;
				case 0x7: //V Sync Position?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x7F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_VERTICAL|0x07); //This CRT Register has been updated!
					break;
				case 0x8: //Interlace mode register?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x3; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_VERTICAL|0x8); //CRT Mode Control Register has been updated!
					updateCGAmapping(); //Update the new CGA mapping if required!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL); //CRT Mode Control Register has been updated!
					break;
				case 0x9: //Max scan line address?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x1F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER_VERTICAL|0x9); //This CRT Register has been updated!
					break;
				case 0xA: //Cursor Start?
					//Bit 6&5: 00=Non-blink(ON), 01=Non-Display(OFF), 10=Blink 1/16 field rate, 11=Blink 1/32 field rate!
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x7F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER|0xA); //This CRT Register has been updated!
					break;
				case 0xB: //Cursor End?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x1F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER|0xB); //This CRT Register has been updated!
					break;
				case 0xC: //Start address(H)?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x3F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER|getActiveVGA()->registers->CRTControllerRegisters_Index); //This CRT Register has been updated!
					break;
				case 0xD: //Start address(L)?
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER|getActiveVGA()->registers->CRTControllerRegisters_Index); //This CRT Register has been updated!
					break;
				case 0xE: //Cursor(H)?
					getActiveVGA()->registers->CGARegistersMasked[getActiveVGA()->registers->CRTControllerRegisters_Index] = value&0x3F; //Set the CGA register(masked)!
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER|getActiveVGA()->registers->CRTControllerRegisters_Index); //This CRT Register has been updated!
					break;
				case 0xF: //Cursor(L)?
					VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_CGACRTCONTROLLER|getActiveVGA()->registers->CRTControllerRegisters_Index); //This CRT Register has been updated!
					break;
				case 0x10: //Light Pen(H)?
				case 0x11: //Light Pen(L)?
					//These register are read-only!
					break; //Not handled yet!
				default:
					break;
				}
				skipCRTwrite:
				ok = 1; //OK!
				goto finishoutput; //Don't apply the VGA CRT normally!
			}
			ok = 0; //Not CGA/MDA!
			break;

		//CGA/MDA compatibility registers!
		case 0x3D8: //CGA mode control register
			if (getActiveVGA()->registers->specialCGAflags&0x1) //Not NMI used on CGA-specific registers being called?
			{
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(W)Mode Control=%02X",value); //Log the write!
					}
				#endif
				if (getActiveVGA()->registers->Compatibility_CGAModeControl!=value) //Value changed?
				{
					getActiveVGA()->registers->Compatibility_CGAModeControl = value; //Set the MDA Mode Control Register!
					applyCGAModeControl(); //Only apply when needed!			
				}
				if (value&0x8) //We're enabled?
				{
					getActiveVGA()->registers->specialCGAflags |= 0x40; //Enable CGA on VGA if needed!
					if ((getActiveVGA()->registers->specialMDAflags&0xC1)==0xC1) //MDA extension enabled?
					{
						applyCGAMDAMode();
					}
				}
				else //We're disabled?
				{
					getActiveVGA()->registers->specialCGAflags &= ~0x40; //Disable CGA on VGA if needed!
				}
				ok = 1; //OK!
			}
			break;
		case 0x3D9: //CGA palette register
			if (getActiveVGA()->registers->specialCGAflags&0x1) //Not NMI used on CGA-specific registers being called?
			{
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(W)Write Palette=%02X",value); //Log the write!
					}
				#endif
				if (getActiveVGA()->registers->Compatibility_CGAPaletteRegister!=value) //Value changed?
				{
					getActiveVGA()->registers->Compatibility_CGAPaletteRegister = value; //Set the MDA Mode Control Register!
					applyCGAPaletteRegister();
				}
				ok = 1; //OK!
			}
			break;
		case 0x3B8: //MDA Mode Control Register
			if (getActiveVGA()->registers->specialMDAflags&0x1) //Not NMI used on MDA-specific registers being called? Also emulate with CGA enabled!
			{
				if (getActiveVGA()->registers->Compatibility_MDAModeControl!=value) //Value changed?
				{
					getActiveVGA()->registers->Compatibility_MDAModeControl = value; //Set the MDA Mode Control Register!
					applyMDAModeControl();
				}
				if (value&0x8) //We're enabled?
				{
					getActiveVGA()->registers->specialMDAflags |= 0x40; //Enable MDA on VGA if needed!
					if ((getActiveVGA()->registers->specialMDAflags&0xC1)==0xC1) //MDA extension enabled?
					{
						applyCGAMDAMode();
					}
				}
				else //We're disabled?
				{
					getActiveVGA()->registers->specialMDAflags &= ~0x40; //Disable MDA on VGA if needed!
				}
				ok = 1; //OK!
			}
			break;
		case 0x3DB: //Clear lightpen latch?
			if (CGAMDAEMULATION_ENABLED(getActiveVGA()))  //Special CGA flag set for CRTC?
			{
				CGA_clearlightpenlatch(); //Clear lightpen latch!
				ok = 2; //Accept, but ignore!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(W)Clear lightpen latch"); //Log the write!
					}
				#endif
			}
			break;
		case 0x3DC: //Preset lightpen latch?
			if (CGAMDAEMULATION_ENABLED(getActiveVGA()))  //Special CGA flag set for CRTC?
			{
				CGA_presetlightpenlatch(); //Preset lightpen latch!
				ok = 2; //Accept, but ignore!
				#ifdef VGAIODUMP
					if (dumpCGAIO()) //To dump?
					{
						dolog("CGA_IO","(W)Preset lightpen latch"); //Log the write!
					}
				#endif
			}
			break;
		default:
			break;
		}
		finishoutput:
		updateCGAMDAflags(); //Update the CGA/MDA flags if needed!
	}
	return ok;
}

void initCGA_MDAState() //Initialise our compatibility layer!
{
	uint_32 input,divided,divider;
	if (getActiveVGA()) //Gotten active VGA? Initialise the full hardware if needed!
	{
		if ((getActiveVGA()->registers->specialMDAflags&0x81)==1) //Pure MDA mode?
		{
			SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1,0); //Mono(MDA) mode!
			applyMDAModeControl();
			applyCGAMDAMode(); //Make sure we're initialized!
			VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL); //We have been updated!	
			getActiveVGA()->enable_SVGA = 4; //We're a special VGA extension!
			
			//Precalc all 9 dividers for a 16-bit range!
			for (input = 0, divided = 0, divider = 0; input < 0x10000;++input) //Precalc all possible inputs!
			{
				getActiveVGA()->precalcs.divideby9[input] = divided; //Divided!
				if (unlikely(++divider == 9)) //9 dividers processed?
				{
					divider = 0; //Reset divider!
					++divided; //Next divided is to be started!
				}
			}
		}
		if ((getActiveVGA()->registers->specialCGAflags&0x81)==1) //Pure CGA mode?
		{
			SETBITS(getActiveVGA()->registers->ExternalRegisters.MISCOUTPUTREGISTER,0,1,1); //Color(CGA) mode!
			applyCGAModeControl();
			applyCGAPaletteRegister();
			applyCGAMDAMode(); //Make sure we're initialized!
			VGA_calcprecalcs(getActiveVGA(),WHEREUPDATED_ALL); //We have been updated!	
			getActiveVGA()->enable_SVGA = 4; //We're a special VGA extension!
		}
	}
}

void initCGA_MDA()
{
	VGA_registerExtension(&CGAMDA_readIO,&CGAMDA_writeIO,&initCGA_MDAState,NULL,&getCGAMDAClock,NULL); //Register our extension handlers for I/O!
}
